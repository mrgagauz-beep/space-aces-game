"""
Mini-map vision utilities for Space Aces Bot.

This module handles detection of player and enemies on the mini-map
using HSV thresholds and simple contour analysis.
"""

from typing import List, Optional, Tuple

import cv2
import numpy as np
import logging

from config.config import Config
from utils.logger import setup_logger
from vision.capture import grab_minimap

setup_logger()
logger = logging.getLogger(__name__)

# Последняя удачная позиция игрока на миникарте (в координатах ROI миникарты).
_LAST_PLAYER_MM: Optional[Tuple[int, int]] = None


def _extract_inner_minimap(
    minimap_bgr: np.ndarray, cfg: Optional[Config] = None
) -> Tuple[Optional[np.ndarray], int, int]:
    """
    Вырезает внутреннюю часть миникарты по процентным отступам из профиля.

    Использует cfg.minimap_inner_margin_pct(), если он есть; иначе берёт
    разумные значения по умолчанию. Возвращает подкадр и смещение по X/Y
    относительно исходного ROI миникарты.
    """
    if minimap_bgr is None or minimap_bgr.size == 0:
        return None, 0, 0

    h, w = minimap_bgr.shape[:2]

    margins = (
        cfg.minimap_inner_margin_pct()
        if cfg is not None and hasattr(cfg, "minimap_inner_margin_pct")
        else {}
    )
    top = margins.get("top", 0.22)
    bottom = margins.get("bottom", 0.12)
    left = margins.get("left", 0.15)
    right = margins.get("right", 0.05)

    x0 = int(w * left)
    x1 = int(w * (1.0 - right))
    y0 = int(h * top)
    y1 = int(h * (1.0 - bottom))

    inner = minimap_bgr[y0:y1, x0:x1]
    return inner, x0, y0


def find_player_crosshair(
    minimap_bgr: np.ndarray, cfg: Optional[Config] = None
) -> Optional[Tuple[int, int]]:
    """
    Находит позицию игрока по пересечению вертикальной и горизонтальной циановой/белой линии
    во внутренней части миникарты.

    1) Строит HSV-маску линий.
    2) Считает суммы по столбцам и строкам.
    3) Берёт максимум по каждой оси.

    Если в кадре линии плохо видны, возвращает последнюю удачную позицию.
    Координаты — в системе ROI миникарты (x, y).
    """
    global _LAST_PLAYER_MM

    inner, x0, y0 = _extract_inner_minimap(minimap_bgr, cfg)
    if inner is None or inner.size == 0:
        return _LAST_PLAYER_MM

    h, w = inner.shape[:2]
    _ = (h, w)  # для удобства отладки, чтобы линтер не ругался

    hsv = cv2.cvtColor(inner, cv2.COLOR_BGR2HSV)
    hsv_cfg = cfg.hsv() if cfg is not None and hasattr(cfg, "hsv") else {}

    line1_min = np.array(
        hsv_cfg.get("player_minimap_line_1_min", [75, 40, 120]), dtype=np.uint8
    )
    line1_max = np.array(
        hsv_cfg.get("player_minimap_line_1_max", [110, 255, 255]), dtype=np.uint8
    )
    line2_min = np.array(
        hsv_cfg.get("player_minimap_line_2_min", [0, 0, 180]), dtype=np.uint8
    )
    line2_max = np.array(
        hsv_cfg.get("player_minimap_line_2_max", [179, 80, 255]), dtype=np.uint8
    )

    mask1 = cv2.inRange(hsv, line1_min, line1_max)
    mask2 = cv2.inRange(hsv, line2_min, line2_max)
    mask = cv2.bitwise_or(mask1, mask2)

    kernel = np.ones((3, 3), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel, iterations=1)
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel, iterations=1)

    # суммарная "яркость" по столбцам и строкам
    col_sum = mask.sum(axis=0).astype(np.float32)
    row_sum = mask.sum(axis=1).astype(np.float32)

    # если маска почти пустая — fallback к прошлой позиции или None
    if col_sum.max() < 1.0 or row_sum.max() < 1.0:
        return _LAST_PLAYER_MM

    vert_x = int(np.argmax(col_sum))
    horiz_y = int(np.argmax(row_sum))

    global_x = x0 + vert_x
    global_y = y0 + horiz_y

    _LAST_PLAYER_MM = (global_x, global_y)
    return _LAST_PLAYER_MM


def find_enemies(
    minimap_bgr: np.ndarray,
    cfg: Config,
    map_name: Optional[str] = None,
) -> List[Tuple[int, int]]:
    """
    Простой детектор врагов (красные точки) на миникарте.

    - Использует только HSV-маску красного.
    - Работает во внутренней части миникарты.
    - Фильтрует по базовым размерам контура.

    НЕ вычитает позицию игрока и не учитывает ignore-зоны, чтобы не ломать детекцию.
    Возвращает список координат (x, y) в системе координат ROI миникарты.
    """
    inner, x0, y0 = _extract_inner_minimap(minimap_bgr, cfg)
    if inner is None or inner.size == 0:
        logger.warning("Empty minimap frame passed to find_enemies")
        return []

    hsv = cv2.cvtColor(inner, cv2.COLOR_BGR2HSV)
    hsv_cfg = cfg.hsv() if hasattr(cfg, "hsv") else {}

    def _val(key: str, default: list[int]) -> np.ndarray:
        return np.array(hsv_cfg.get(key, default), dtype=np.uint8)

    red1_min = _val("enemy_minimap_red_1_min", [0, 102, 64])
    red1_max = _val("enemy_minimap_red_1_max", [8, 255, 255])
    red2_min = _val("enemy_minimap_red_2_min", [170, 102, 64])
    red2_max = _val("enemy_minimap_red_2_max", [179, 255, 255])

    mask1 = cv2.inRange(hsv, red1_min, red1_max)
    mask2 = cv2.inRange(hsv, red2_min, red2_max)
    mask = cv2.bitwise_or(mask1, mask2)

    kernel = np.ones((3, 3), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel, iterations=1)
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel, iterations=1)

    contours, _ = cv2.findContours(
        mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
    )

    det_cfg = (
        cfg.minimap_enemy_detector()
        if hasattr(cfg, "minimap_enemy_detector")
        else {}
    )
    area_min = det_cfg.get("area_min", 3)
    area_max = det_cfg.get("area_max", 500)
    bbox_min = det_cfg.get("bbox_min", 2)
    bbox_max = det_cfg.get("bbox_max", 25)

    enemies: List[Tuple[int, int]] = []

    for c in contours:
        x, y, w_box, h_box = cv2.boundingRect(c)
        area = w_box * h_box
        if area < area_min or area > area_max:
            continue
        if w_box < bbox_min or w_box > bbox_max:
            continue
        if h_box < bbox_min or h_box > bbox_max:
            continue

        cx = x + w_box // 2
        cy = y + h_box // 2

        gx = x0 + cx
        gy = y0 + cy

        enemies.append((gx, gy))

    return enemies


if __name__ == "__main__":
    cfg = Config()
    minimap_frame = grab_minimap(cfg)

    player = find_player_crosshair(minimap_frame, cfg)
    enemies = find_enemies(minimap_frame, cfg)

    logger.info("Sanity minimap: player=%s, enemies=%d", player, len(enemies))


